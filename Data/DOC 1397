Title : Buffer over-read
Text : In [[computer security]] and [[computer programming|programming]], a '''buffer over-read'''<ref>{{cite web |url=http://cwe.mitre.org/data/definitions/126.html |title=CWE – CWE-126: Buffer Over-read (2.6) |publisher=Cwe.mitre.org |date=February 18, 2014 |accessdate=April 10, 2014}}</ref><ref>{{Cite journal|last=Strackx|first=Raoul|last2=Younan|first2=Yves|last3=Philippaerts|first3=Pieter|last4=Piessens|first4=Frank|last5=Lachmund|first5=Sven|last6=Walter|first6=Thomas|date=2009-01-01|title=Breaking the Memory Secrecy Assumption|url=http://doi.acm.org/10.1145/1519144.1519145|journal=Proceedings of the Second European Workshop on System Security|series=EUROSEC '09|location=New York, NY, USA|publisher=ACM|pages=1–8|doi=10.1145/1519144.1519145|isbn=9781605584720}}</ref> is an [[anomaly in software|anomaly]] where a [[computer program|program]], while reading [[data]] from a [[buffer (computer science)|buffer]], overruns the buffer's boundary and reads (or tries to read) adjacent memory.  This is a special case of violation of [[memory safety]].

Buffer over-reads can be triggered, as in the [[Heartbleed]] bug, by maliciously crafted inputs that are designed to exploit a lack of [[bounds checking]] to read parts of memory not intended to be accessible. They may also be caused by programming errors alone. Buffer over-reads can result in erratic program behavior, including [[random-access memory|memory]] access errors, incorrect results, a [[crash (computing)|crash]], or a breach of system security. Thus, they are the basis of many [[vulnerability (computer science)|software vulnerabilities]] and can be maliciously [[exploit (computer security)|exploited]] to access privileged information.

[[Programming language]]s commonly associated with buffer over-reads include [[C (programming language)|C]] and [[C++]], which provide no built-in protection against using [[Pointer (computer programming)|pointers]] to access data in any part of [[virtual memory]], and which do not automatically check that reading data from a block of memory is safe; respective examples are attempting to read more elements than contained in an array, or failing to append a trailing terminator to a [[null-terminated string]]. [[Bounds checking]] can prevent buffer over-reads,<ref>{{cite web
 | url = http://www.fort-knox.org/files/younan_malloc.pdf
 | title = Efficient protection against heap-based buffer overflows without resorting to magic
 | date = 2013-02-25 | accessdate = 2014-04-24
 | author1 = Yves Younan | author2 = Wouter Joosen | author3 = Frank Piessens
 | publisher = Dept. of Computer Science, Katholieke Universiteit Leuven
 | format = PDF
}}</ref> while [[fuzz testing]] can help detect them.

== See also ==
{{Portal|Computer programming}}

* [[Buffer overflow]]
* [[Computer security]]
* [[Type safety]]

== References ==
{{Reflist}}

== External links ==
* [https://web.archive.org/web/20140424142313/http://telussecuritylabs.com/threats/show/TSL20140102-03 PHP DateInterval Heap Buffer Overread Denial of Service]
* [https://bugs.php.net/bug.php?id=66060 PHP Bug #66060: Heap buffer over-read in DateInterval]

{{Memory management navbox}}

{{DEFAULTSORT:Buffer Over-read}}
[[Category:Software bugs]]
[[Category:Computer memory]]
[[Category:Computer security exploits]]


{{Computer-security-stub}}
